(*-----------Evalutation-----------*)

(*Key generation*)

let p = 41
let q = 83
let n = 3403
let phi = 3280
let public_key = 17
let private_key = 193

(* [string_to_list s ] Transforms string [s] into a list of  characters in [s]
 * Requires:
 *  - s is a valid string type*)
let string_to_list (s: string) =
  let rec helper c len =
    if c = len then []
    else (String.get s c)::(helper (c+1) len)
  in
  helper 0 (String.length s)

(* [(^^) x y defines an infix operator that concatenates integer [x] and
 * integer [y]. Example: 5 ^^ 3 = 53
 * Requires:
 *  - x is a valid integer
 *  - y is a valid integer *)
let (^^) x y =
  let x' = string_of_int x in
  let y' = string_of_int y in
  int_of_string(x'^y')

(* [exponentiate x y] raises [x] to power [y]
 * Requires:
 *  - x is a valid integer
 *  - y is a valid integer >= 0*)
let rec exponentiate x y =
  match y with
  | 0 -> 1
  | 1 -> x
  | n -> if (n mod 2 = 0) then exponentiate (x*x) (n/2)
         else x * exponentiate (x*x) ((n-1)/2)

(* [is_upper x] Determines whether the character is uppercase
 * Requires:
 *  - x is a valid character of the upper or lowercase English alphabet*)
let is_upper x=
  (Char.code x > 64 && Char.code x < 91)

(* [list_to_digits lst] Tranforms a list of characters into their respective
 * ASCII values
 * Requires:
 *  - lst is a list of characters of the upper or lowercase English alphabet *)
let rec list_to_digits lst : int =
  match lst with
    | [] -> 0
    | h::t -> if is_upper h
              then let code = Char.code h - 65 in
                    code^^(list_to_digits t)
              else let code = Char.code h - 70 in
                    code^^(list_to_digits t)

(*[encrypt str] encrypts a string using RSA
 *requires:
 *  -str:string *)
let encrypt str =
  let msg = (list_to_digits str)/10 in
  (exponentiate msg public_key) mod n

(*[decrypt msg] returns a string of ints that correspond to a msg
 *requires:
 *  -msg is a large int representing the encoding of an English msg*)
let decrypt str =
  let encrypted = encrypt str i
  (exponentiate encrypted private_key) mod n


(*------------------Printing and steps------------------*)
let print_stuff = ref ""

let to_print = !(print_stuff)

(*[step_1] generates the large primes*)
let step_1 =
  print_stuff := "First lets generate two large primes
p = 41 and q=83."

(*[step_2] defines and generates the modulus*)
let step_2 =
  print_stuff := "Next we generate the modulus n by computing
  p*q = 3403"

(*[step_3] defines and computes the totient*)
let step_3 =
  print_stuff := "Now define the totient of the modulus, i.e
  the number of units in n. In our case, this is totient =
  (p-1)*(q-1) = 3280."

(*[step_4] explains how to generate the public key*)
let step_4 =
  print_stuff := "We need a public key, or in other words, a large
  prime exponent that we can use to encrypt our message. Let's
  choose k = 17."

(*[step_5] explains how to generate the private key*)
let step_5 =
  print_stuff := "The private key is generated by the recepient, defined
  as the inverse of k with respect to mod (totient). We can compute this
  by using the extended Euclidean algorithm, so that as-bt = 17s - 3403t = 1.
  This turns out to be 193."

(*[step_6] prints the user's determined fields for public and private
 *keys as well as the large primes*)
let step_6 =
  print_stuff := "So now we have the following definitions:
    let p = 41
    let q = 83
    let n = 3403
    let phi = 3280
    let public_key = 17
    let private_key = 193"

(*[step_7 msg] encrypts the user's message, and displays the resulting
 *encryption*)
let step_7 msg =
  let encrpyted_msg = string_of_int (encrypt msg) in
  print_stuff := "The encrypted message then is calculated by
  computing [msg]**17 mod (3403). The result is the following:
  " ^ " " ^ encrpyted_msg

(*[step_8 msg] decrypts the message to a large int displayed on the
 *screen. It also shows the user's orginal message*)
let step_8 msg =
  let decrypted_msg = string_of_int (decrypt msg) in
  print_stuff := "The decrypted message is then " ^ " " ^ decrypted_msg ^ ".
  Which corresponds to our original message" ^ msg ^"."



